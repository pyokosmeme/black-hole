<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inhabited Space - 2370 SolUT</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&family=Space+Mono:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Black hole dependencies -->
    <script src="js-libs/jquery-2.1.4.min.js"></script>
    <script src="js-libs/three.min.js"></script>
    <script src="js-libs/OrbitControls.js"></script>
    <script src="js-libs/Detector.js"></script>
    <script src="js-libs/stats.min.js"></script>
    <script src="js-libs/ShaderLoader.min.js"></script>
    <script src="js-libs/mustache.min.js"></script>
    <script src="js-libs/dat.gui.min.js"></script>
    <script src="three-js-monkey-patch.js"></script>
    
    <!-- Black hole dependencies -->
    <script src="js-libs/jquery-2.1.4.min.js"></script>
    <script src="js-libs/three.min.js"></script>
    <script src="js-libs/OrbitControls.js"></script>
    <script src="js-libs/Detector.js"></script>
    <script src="js-libs/stats.min.js"></script>
    <script src="js-libs/ShaderLoader.min.js"></script>
    <script src="js-libs/mustache.min.js"></script>
    <script src="js-libs/dat.gui.min.js"></script>
    <script src="three-js-monkey-patch.js"></script>
    
    <style>
        /* ═══════════════════════════════════════════════════════════════
           ACIDBURN TRANSIT MAP
           ═══════════════════════════════════════════════════════════════ */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyan: #00ffff;
            --purple: #bf00ff;
            --magenta: #ff00ff;
            --green: #00ff88;
            --pink: #ff0099;
            --dark: #000000;
            --panel: rgba(5, 5, 15, 0.85);
            
            /* Faction colors */
            --uplb: #4a9eff;
            --swi: #51cf66;
            --hw: #a78bfa;
            --inter: #fbbf24;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            min-height: 100vh;
            background: var(--dark);
            color: #fff;
            font-family: 'Share Tech Mono', monospace;
            overflow-x: hidden;
        }

        /* ═══════════════════════════════════════════════════════════════
           STARFIELD BACKGROUND
           ═══════════════════════════════════════════════════════════════ */

        #starfield-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background: radial-gradient(ellipse at center, #0a0015 0%, #000008 50%, #000000 100%);
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s ease-in-out infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* Scanlines */
        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 10000;
            animation: scan 0.1s linear infinite;
        }

        @keyframes scan {
            to { transform: translateY(6px); }
        }

        /* ═══════════════════════════════════════════════════════════════
           HEADER BAR - MAXIMUM TEXTURE
           ═══════════════════════════════════════════════════════════════ */

        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            overflow: hidden;
        }

        .header-bar::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                repeating-linear-gradient(-60deg, var(--purple) 0px, var(--purple) 6px, transparent 6px, transparent 12px),
                repeating-linear-gradient(60deg, var(--cyan) 0px, var(--cyan) 4px, transparent 4px, transparent 14px),
                repeating-linear-gradient(-45deg, rgba(255, 0, 153, 0.5) 0px, rgba(255, 0, 153, 0.5) 2px, transparent 2px, transparent 6px),
                repeating-linear-gradient(75deg, rgba(0, 255, 255, 0.4) 0px, rgba(0, 255, 255, 0.4) 3px, transparent 3px, transparent 9px),
                linear-gradient(90deg, var(--purple), var(--cyan), var(--magenta), var(--cyan), var(--purple));
            z-index: -2;
        }

        .header-texture {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(90deg, transparent 0px, transparent 2px, rgba(0,0,0,0.2) 2px, rgba(0,0,0,0.2) 4px),
                repeating-linear-gradient(0deg, transparent 0px, transparent 3px, rgba(255,255,255,0.08) 3px, rgba(255,255,255,0.08) 4px);
            z-index: -1;
            mix-blend-mode: overlay;
        }

        .header-bar::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--cyan), var(--purple), var(--cyan));
            box-shadow: 0 0 15px var(--cyan);
        }

        .header-left {
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        .header-title {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 20px;
            color: #000;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            letter-spacing: 3px;
        }

        .header-subtitle {
            font-family: 'VT323', monospace;
            font-size: 16px;
            color: rgba(0,0,0,0.8);
            letter-spacing: 2px;
        }

        /* Mode Toggle */
        .mode-toggle-container {
            display: flex;
            gap: 10px;
            z-index: 10;
        }

        .mode-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid var(--cyan);
            color: var(--cyan);
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .mode-btn:hover {
            background: rgba(0, 255, 255, 0.2);
            box-shadow: 0 0 20px var(--cyan);
        }

        .mode-btn.active {
            background: var(--cyan);
            color: #000;
            box-shadow: 0 0 25px var(--cyan);
        }

        /* ═══════════════════════════════════════════════════════════════
           MAIN CONTENT
           ═══════════════════════════════════════════════════════════════ */

        .container {
            position: relative;
            z-index: 10;
            padding: 80px 20px 40px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            min-height: calc(100vh - 140px);
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* ═══════════════════════════════════════════════════════════════
           MAP CONTAINER
           ═══════════════════════════════════════════════════════════════ */

        #map-container {
            background: var(--panel);
            border: 3px solid transparent;
            border-image: linear-gradient(135deg, var(--purple), var(--cyan), var(--purple)) 1;
            position: relative;
            backdrop-filter: blur(10px);
            overflow: hidden;
            min-height: 600px;
        }

        #map-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: 
                repeating-linear-gradient(-55deg, var(--purple) 0px, var(--purple) 5px, transparent 5px, transparent 10px),
                repeating-linear-gradient(55deg, var(--cyan) 0px, var(--cyan) 4px, transparent 4px, transparent 12px),
                linear-gradient(90deg, var(--purple), var(--cyan), var(--purple));
            z-index: 10;
        }

        #transit-map {
            width: 100%;
            height: 100%;
            min-height: 600px;
            display: block;
        }

        #three-container {
            width: 100%;
            height: 100%;
            min-height: 600px;
            display: none;
            position: relative;
        }

        #three-container canvas {
            display: block;
        }

        #three-container.active {
            display: block;
        }

        #transit-map.hidden {
            display: none;
        }

        /* 3D Controls Hint */
        .controls-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--panel);
            border: 1px solid var(--cyan);
            padding: 10px 15px;
            font-size: 11px;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
            z-index: 100;
        }

        .controls-hint kbd {
            background: rgba(0, 255, 255, 0.2);
            border: 1px solid var(--cyan);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Share Tech Mono', monospace;
            color: var(--cyan);
        }

        /* SVG Styles */
        .route-line {
            stroke-width: 3;
            opacity: 0.4;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .route-line.active {
            opacity: 1;
            stroke-width: 5;
            filter: drop-shadow(0 0 8px currentColor);
        }

        .uplb-route { stroke: var(--uplb); }
        .swi-route { stroke: var(--swi); }
        .hw-route { stroke: var(--hw); }
        .inter-route { stroke: var(--inter); stroke-dasharray: 8, 4; }

        .station-group {
            cursor: pointer;
        }

        .station-group:hover .station-circle {
            filter: drop-shadow(0 0 15px currentColor);
            stroke-width: 4;
        }

        .station-group:hover .station-label {
            fill: var(--cyan);
        }

        .station-hit-area {
            fill: transparent;
            cursor: pointer;
        }

        .station-circle {
            transition: all 0.15s ease;
            pointer-events: none;
            fill: #0a0a1a;
            stroke-width: 3;
        }

        .station-circle.faction-uplb { stroke: var(--uplb); }
        .station-circle.faction-swi { stroke: var(--swi); }
        .station-circle.faction-hw { stroke: var(--hw); }

        .station-circle.selected {
            fill: var(--cyan) !important;
            stroke: var(--cyan) !important;
            filter: drop-shadow(0 0 15px var(--cyan));
        }

        .station-circle.in-route {
            fill: var(--purple) !important;
            stroke: var(--purple) !important;
            filter: drop-shadow(0 0 10px var(--purple));
        }

        .station-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 700;
            fill: #fff;
            pointer-events: none;
            transition: fill 0.15s ease;
        }

        .station-sublabel {
            font-family: 'VT323', monospace;
            font-size: 12px;
            fill: var(--cyan);
            opacity: 0.8;
            pointer-events: none;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--panel);
            border: 2px solid var(--purple);
            padding: 15px 20px;
            backdrop-filter: blur(5px);
            z-index: 100;
        }

        .legend h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--purple);
            letter-spacing: 2px;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
        }

        .legend-line {
            width: 30px;
            height: 3px;
        }

        .legend-line.uplb-route { background: var(--uplb); }
        .legend-line.swi-route { background: var(--swi); }
        .legend-line.hw-route { background: var(--hw); }
        .legend-line.inter-route { 
            background: repeating-linear-gradient(90deg, var(--inter) 0px, var(--inter) 8px, transparent 8px, transparent 12px);
        }

        /* ═══════════════════════════════════════════════════════════════
           ROUTE PLANNER PANEL
           ═══════════════════════════════════════════════════════════════ */

        .route-planner {
            background: var(--panel);
            border: 3px solid transparent;
            border-image: linear-gradient(135deg, var(--cyan), var(--purple)) 1;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            max-height: calc(100vh - 120px);
            overflow: hidden;
            position: relative;
        }

        .route-planner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: 
                repeating-linear-gradient(-55deg, var(--cyan) 0px, var(--cyan) 5px, transparent 5px, transparent 10px),
                repeating-linear-gradient(55deg, var(--purple) 0px, var(--purple) 4px, transparent 4px, transparent 12px),
                linear-gradient(90deg, var(--cyan), var(--purple), var(--cyan));
        }

        .planner-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 20px 15px;
            border-bottom: 1px solid rgba(191, 0, 255, 0.3);
        }

        .planner-header h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--cyan);
            letter-spacing: 3px;
        }

        .clear-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            padding: 8px 15px;
            background: transparent;
            border: 2px solid var(--pink);
            color: var(--pink);
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            background: var(--pink);
            color: #000;
            box-shadow: 0 0 20px var(--pink);
        }

        #route-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Scrollbar */
        #route-content::-webkit-scrollbar {
            width: 6px;
        }

        #route-content::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
        }

        #route-content::-webkit-scrollbar-thumb {
            background: var(--purple);
            border-radius: 3px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            filter: grayscale(0.5);
        }

        .empty-state-text {
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            line-height: 1.6;
        }

        /* Route Display */
        .route-display {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .route-stop {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--cyan);
            padding: 6px 12px;
            border-radius: 3px;
        }

        .stop-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--purple);
            background: rgba(191, 0, 255, 0.2);
            padding: 2px 6px;
            border-radius: 2px;
        }

        .stop-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--cyan);
        }

        .stop-arrow {
            color: var(--purple);
            font-size: 16px;
        }

        /* Totals */
        .totals-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 12px;
            margin-bottom: 25px;
        }

        .total-box {
            background: rgba(191, 0, 255, 0.1);
            border: 1px solid var(--purple);
            padding: 18px 12px;
            text-align: center;
        }

        .total-label {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 1px;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .total-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
        }

        .total-unit {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            margin-left: 4px;
        }

        /* Leg Details */
        .leg-details h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--purple);
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .leg-item {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--cyan);
            padding: 12px 15px;
            margin-bottom: 10px;
        }

        .leg-route {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #fff;
            margin-bottom: 8px;
        }

        .leg-times {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .leg-time {
            font-size: 11px;
        }

        .leg-time-label {
            color: rgba(255,255,255,0.5);
        }

        .leg-time-value {
            color: var(--green);
            font-family: 'VT323', monospace;
            font-size: 14px;
            margin-left: 5px;
        }

        /* ═══════════════════════════════════════════════════════════════
           FOOTER
           ═══════════════════════════════════════════════════════════════ */

        .footer {
            text-align: center;
            padding: 30px 20px;
            margin-top: 20px;
        }

        .footer p {
            font-size: 12px;
            color: rgba(255,255,255,0.3);
        }

        .footer a {
            color: var(--cyan);
            text-decoration: none;
            border-bottom: 1px solid var(--purple);
            transition: all 0.2s ease;
        }

        .footer a:hover {
            color: var(--purple);
            border-color: var(--cyan);
            text-shadow: 0 0 10px var(--purple);
        }

        /* ═══════════════════════════════════════════════════════════════
           GLITCH EFFECT
           ═══════════════════════════════════════════════════════════════ */

        body.glitch {
            animation: glitchEffect 0.15s linear;
        }

        @keyframes glitchEffect {
            0%, 100% { transform: translate(0); filter: hue-rotate(0); }
            25% { transform: translate(-2px, 1px); filter: hue-rotate(90deg); }
            50% { transform: translate(2px, -1px); filter: hue-rotate(180deg); }
            75% { transform: translate(-1px, -2px); filter: hue-rotate(270deg); }
        }

        /* 3D Station Tooltip */
        #tooltip-3d {
            position: fixed;
            background: var(--panel);
            border: 2px solid var(--cyan);
            padding: 10px 15px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--cyan);
            pointer-events: none;
            z-index: 1001;
            display: none;
            backdrop-filter: blur(10px);
        }

        #tooltip-3d .tooltip-name {
            font-weight: 700;
            margin-bottom: 5px;
        }

        #tooltip-3d .tooltip-pop {
            font-family: 'VT323', monospace;
            color: rgba(255,255,255,0.7);
            font-size: 14px;
        }

        #tooltip-3d .tooltip-faction {
            font-size: 10px;
            color: var(--purple);
            letter-spacing: 1px;
            margin-top: 3px;
        }

        #tooltip-3d .tooltip-system {
            font-size: 10px;
            color: var(--green);
            letter-spacing: 1px;
            margin-top: 3px;
            border-top: 1px solid rgba(0, 255, 136, 0.3);
            padding-top: 3px;
        }

        /* Axis Labels for 3D */
        .axis-label {
            position: absolute;
            font-family: 'VT323', monospace;
            font-size: 14px;
            color: rgba(255,255,255,0.5);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Starfield Background -->
    <div id="starfield-bg"></div>

    <!-- 3D Tooltip -->
    <div id="tooltip-3d">
        <div class="tooltip-name"></div>
        <div class="tooltip-pop"></div>
        <div class="tooltip-faction"></div>
        <div class="tooltip-system"></div>
    </div>

    <!-- Header -->
    <header class="header-bar">
        <div class="header-texture"></div>
        <div class="header-left">
            <div class="header-title">INHABITED SPACE TRANSIT NETWORK</div>
            <div class="header-subtitle">K-Tube Route Planner • ERR-AL Drive • 2370 SolUT</div>
        </div>
        <div class="mode-toggle-container">
            <button class="mode-btn active" id="btn-2d" onclick="setMode('2d')">2D SUBWAY</button>
            <button class="mode-btn" id="btn-3d" onclick="setMode('3d')">3D STELLAR</button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="main-content">
            <div id="map-container">
                <svg id="transit-map" viewBox="0 0 1600 1000"></svg>
                <div id="three-container"></div>
                
                <div class="legend">
                    <h3>FACTION ROUTES</h3>
                    <div class="legend-item">
                        <div class="legend-line uplb-route"></div>
                        <span>UPLB</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line swi-route"></div>
                        <span>SWI</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line hw-route"></div>
                        <span>Homeworlds</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line inter-route"></div>
                        <span>Inter-faction</span>
                    </div>
                </div>
                
                <div class="controls-hint" id="controls-hint" style="display: none;">
                    <kbd>Drag</kbd> Rotate &nbsp; <kbd>Scroll</kbd> Zoom &nbsp; <kbd>Right-click</kbd> Pan
                </div>
            </div>
            
            <div class="route-planner">
                <div class="planner-header">
                    <h2>ROUTE PLANNER</h2>
                    <button class="clear-btn" onclick="clearRoute()">CLEAR ROUTE</button>
                </div>
                
                <div id="route-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">✧</div>
                        <div class="empty-state-text">Click stations on the map to plan your route</div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <p>transit data current as of 2370.127 SolUT ;; <a href="#">network status: nominal</a></p>
        </footer>
    </div>

    <script>
        // ═══════════════════════════════════════════════════════════════
        // GENERATE STARFIELD
        // ═══════════════════════════════════════════════════════════════
        
        (function generateStarfield() {
            const bg = document.getElementById('starfield-bg');
            for (let i = 0; i < 200; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.width = star.style.height = (Math.random() * 2 + 1) + 'px';
                star.style.animationDelay = Math.random() * 3 + 's';
                star.style.animationDuration = (Math.random() * 2 + 2) + 's';
                bg.appendChild(star);
            }
        })();

        // ═══════════════════════════════════════════════════════════════
        // GLITCH EFFECT
        // ═══════════════════════════════════════════════════════════════

        setInterval(() => {
            if (Math.random() > 0.92) {
                document.body.classList.add('glitch');
                setTimeout(() => document.body.classList.remove('glitch'), 100);
            }
        }, 3000);

        // ═══════════════════════════════════════════════════════════════
        // STATION DATA - 2D AND 3D COORDINATES
        // ═══════════════════════════════════════════════════════════════

        // 3D coordinates in light years from Sol (from project knowledge)
        // Alpha Centauri system: Rigil Kentaurus (A), Toliman (B), and Proxima (C)
        // Proxima orbits AB pair at ~13,000 AU (~0.2 ly), we spread them slightly for visibility
        const alphaCentauriCenter = [-1.60, -1.28, -3.80]; // ~4.37 ly from Sol
        
        const stations3D = {
            'Sol':       { coords: [0, 0, 0], pop: 10440, faction: 'UPLB' },
            'Gamov':     { coords: [9.43, 25.19, -31.15], pop: 631, faction: 'UPLB' },
            'Wolf':      { coords: [-0.73, 5.59, 12.78], pop: 432, faction: 'UPLB' },
            'Luyten':    { coords: [6.51, 2.16, -10.16], pop: 322, faction: 'UPLB' },
            'Gowjin':    { coords: [-6.07, -13.15, 4.77], pop: 317, faction: 'UPLB' },
            'Issetock':  { coords: [1.59, 13.18, 15.66], pop: 283, faction: 'UPLB' },
            'Nursia':    { coords: [-20.32, -32.91, 7.59], pop: 411, faction: 'UPLB' },
            'Bakunawa':  { coords: [-7.60, -39.75, -3.60], pop: 215, faction: 'UPLB' },
            'Vega':      { coords: [-21.77, 8.24, 9.03], pop: 262, faction: 'SWI' },
            'Ya Ke':     { coords: [-52.0, 18.0, -35.0], pop: 579, faction: 'SWI' },  // Nu2 CMa approx
            'Zi Wei Yuan': { coords: [-45.59, 26.33, -43.62], pop: 259, faction: 'SWI' },
            'Sipapu':    { coords: [32.45, 9.00, -23.03], pop: 254, faction: 'SWI' },
            // Alpha Centauri system - offset slightly for visual clarity (actual separation ~0.2 ly)
            'Proxima':   { coords: [-1.55, -0.88, -3.57], pop: 397, faction: 'HW', system: 'AlphaCentauri', systemRole: 'C (Proxima)' },
            'Rigil':     { coords: [-1.65, -1.68, -4.03], pop: 649, faction: 'HW', system: 'AlphaCentauri', systemRole: 'A+B (Rigil/Toliman)' },
            'Tartarus':  { coords: [5.56, 9.41, 0.02], pop: 231, faction: 'HW' },
            'Tau Ceti':  { coords: [-0.40, -11.35, -3.39], pop: 228, faction: 'HW' },
            'Barnard':   { coords: [-2.87, 1.40, 4.59], pop: 455, faction: 'HW' }
        };
        
        // Define star systems that contain multiple stations
        const starSystems = {
            'AlphaCentauri': {
                center: alphaCentauriCenter,
                stations: ['Proxima', 'Rigil'],
                label: 'α Centauri System',
                color: 0xa78bfa
            }
        };

        // 2D subway coordinates
        const stations = {
            'Sol': {x: 800, y: 500, pop: 10440, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Gamov': {x: 950, y: 300, pop: 631, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Wolf': {x: 650, y: 250, pop: 432, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Luyten': {x: 500, y: 400, pop: 322, faction: 'UPLB', labelOffset: {x: -60, y: 0}},
            'Gowjin': {x: 500, y: 600, pop: 317, faction: 'UPLB', labelOffset: {x: -60, y: 0}},
            'Issetock': {x: 650, y: 700, pop: 283, faction: 'UPLB', labelOffset: {x: 0, y: 25}},
            'Nursia': {x: 950, y: 700, pop: 411, faction: 'UPLB', labelOffset: {x: 0, y: 25}},
            'Bakunawa': {x: 800, y: 150, pop: 215, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Vega': {x: 1150, y: 450, pop: 262, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Ya Ke': {x: 1400, y: 350, pop: 579, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Zi Wei Yuan': {x: 1400, y: 600, pop: 259, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Sipapu': {x: 1150, y: 700, pop: 254, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Proxima': {x: 300, y: 700, pop: 397, faction: 'HW', labelOffset: {x: -60, y: 10}},
            'Rigil': {x: 400, y: 850, pop: 649, faction: 'HW', labelOffset: {x: 0, y: 25}},
            'Tartarus': {x: 250, y: 550, pop: 231, faction: 'HW', labelOffset: {x: -60, y: 0}},
            'Tau Ceti': {x: 550, y: 900, pop: 228, faction: 'HW', labelOffset: {x: 0, y: 25}},
            'Barnard': {x: 200, y: 850, pop: 455, faction: 'HW', labelOffset: {x: -60, y: 10}}
        };
        
        const routes = [
            {from: 'Sol', to: 'Gamov', proper: 55.58, tau: 6.0, fdr: 24, type: 'uplb'},
            {from: 'Sol', to: 'Wolf', proper: 19.17, tau: 1.92, fdr: 24, type: 'uplb'},
            {from: 'Sol', to: 'Luyten', proper: 17.32, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Gowjin', proper: 20.78, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Issetock', proper: 28.48, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Nursia', proper: 54.86, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Bakunawa', proper: 56.8, tau: null, fdr: null, type: 'uplb'},
            {from: 'Wolf', to: 'Gamov', proper: 31.55, tau: 3.128, fdr: 48, type: 'uplb'},
            {from: 'Vega', to: 'Ya Ke', proper: 87.23, tau: 12.25, fdr: 48, type: 'swi'},
            {from: 'Ya Ke', to: 'Sipapu', proper: 45.45, tau: 4.51, fdr: 24, type: 'swi'},
            {from: 'Gamov', to: 'Zi Wei Yuan', proper: 76.87, tau: 7.62, fdr: 24, type: 'swi'},
            {from: 'Zi Wei Yuan', to: 'Vega', proper: 82.87, tau: 8.22, fdr: 10, type: 'swi'},
            {from: 'Sol', to: 'Proxima', proper: 5.90, tau: 1.0, fdr: 20, type: 'hw'},
            {from: 'Sol', to: 'Rigil', proper: 5.90, tau: 1.0, fdr: 20, type: 'hw'},
            {from: 'Sol', to: 'Tartarus', proper: 15.13, tau: 1.51, fdr: 24, type: 'hw'},
            {from: 'Sol', to: 'Tau Ceti', proper: 16.5, tau: null, fdr: null, type: 'hw'},
            {from: 'Sol', to: 'Barnard', proper: 8.31, tau: null, fdr: null, type: 'hw'},
            {from: 'Sol', to: 'Vega', proper: 35.43, tau: 3.54, fdr: 10, type: 'inter'},
            {from: 'Wolf', to: 'Vega', proper: 21.69, tau: 2.99, fdr: 1, type: 'inter'},
            {from: 'Gamov', to: 'Vega', proper: 74.18, tau: 7.35, fdr: 48, type: 'inter'},
            {from: 'Gamov', to: 'Ya Ke', proper: 76.22, tau: 7.56, fdr: 20, type: 'inter'},
            {from: 'Gamov', to: 'Sipapu', proper: 40.48, tau: 4.01, fdr: 4, type: 'inter'},
            {from: 'Sol', to: 'Ya Ke', proper: 89.5, tau: 8.95, fdr: 48, type: 'inter'},
            {from: 'Sol', to: 'Zi Wei Yuan', proper: 94.48, tau: 9.45, fdr: 10, type: 'inter'},
            {from: 'Sol', to: 'Sipapu', proper: 56.97, tau: 5.697, fdr: 24, type: 'inter'}
        ];

        // ═══════════════════════════════════════════════════════════════
        // FACTION COLORS
        // ═══════════════════════════════════════════════════════════════

        const factionColors = {
            'UPLB': 0x4a9eff,
            'SWI': 0x51cf66,
            'HW': 0xa78bfa
        };

        const routeTypeColors = {
            'uplb': 0x4a9eff,
            'swi': 0x51cf66,
            'hw': 0xa78bfa,
            'inter': 0xfbbf24
        };

        // ═══════════════════════════════════════════════════════════════
        // 2D TRANSIT MAP LOGIC
        // ═══════════════════════════════════════════════════════════════
        
        const svg = document.getElementById('transit-map');
        let plannedRoute = [];
        let routeCircles = {};
        let routeLines = {};
        
        // Draw routes
        routes.forEach((route, idx) => {
            const from = stations[route.from];
            const to = stations[route.to];
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', from.x);
            line.setAttribute('y1', from.y);
            line.setAttribute('x2', to.x);
            line.setAttribute('y2', to.y);
            line.classList.add('route-line', `${route.type}-route`);
            line.dataset.from = route.from;
            line.dataset.to = route.to;
            
            const key = `${route.from}-${route.to}`;
            routeLines[key] = line;
            const reverseKey = `${route.to}-${route.from}`;
            routeLines[reverseKey] = line;
            
            svg.appendChild(line);
        });
        
        // Draw stations
        Object.entries(stations).forEach(([name, data]) => {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('station-group');
            
            const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            hitArea.classList.add('station-hit-area');
            const hitX = data.x - 30 + Math.min(0, data.labelOffset.x);
            const hitY = data.y - 30 + Math.min(0, data.labelOffset.y);
            const hitW = 60 + Math.abs(data.labelOffset.x);
            const hitH = 60 + Math.abs(data.labelOffset.y);
            hitArea.setAttribute('x', hitX);
            hitArea.setAttribute('y', hitY);
            hitArea.setAttribute('width', hitW);
            hitArea.setAttribute('height', hitH);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.classList.add('station-circle', `faction-${data.faction.toLowerCase()}`);
            circle.setAttribute('cx', data.x);
            circle.setAttribute('cy', data.y);
            circle.setAttribute('r', 9);
            
            routeCircles[name] = circle;
            
            const labelX = data.x + data.labelOffset.x;
            const labelY = data.y + data.labelOffset.y;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.classList.add('station-label');
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY);
            label.setAttribute('text-anchor', data.labelOffset.x > 0 ? 'start' : data.labelOffset.x < 0 ? 'end' : 'middle');
            label.textContent = name;
            
            const sublabelY = data.labelOffset.y < 0 ? labelY - 15 : labelY + 15;
            const sublabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sublabel.classList.add('station-sublabel');
            sublabel.setAttribute('x', labelX);
            sublabel.setAttribute('y', sublabelY);
            sublabel.setAttribute('text-anchor', data.labelOffset.x > 0 ? 'start' : data.labelOffset.x < 0 ? 'end' : 'middle');
            sublabel.textContent = `${data.pop}M`;
            
            g.appendChild(hitArea);
            g.appendChild(circle);
            g.appendChild(label);
            g.appendChild(sublabel);
            svg.appendChild(g);
            
            g.addEventListener('click', (e) => {
                e.stopPropagation();
                addStationToRoute(name);
            });
        });
        
        function addStationToRoute(stationName) {
            if (plannedRoute.length > 0 && plannedRoute[plannedRoute.length - 1] === stationName) {
                return;
            }
            
            if (plannedRoute.length === 0) {
                plannedRoute.push(stationName);
            } else {
                const lastStation = plannedRoute[plannedRoute.length - 1];
                const directRoute = findRoute(lastStation, stationName);
                
                if (directRoute) {
                    plannedRoute.push(stationName);
                } else {
                    const path = findPath(lastStation, stationName);
                    if (path && path.length > 0) {
                        path.forEach(station => {
                            if (station !== lastStation) {
                                plannedRoute.push(station);
                            }
                        });
                    } else {
                        plannedRoute.push(stationName);
                    }
                }
            }
            
            updateRouteDisplay();
        }
        
        function findPath(start, end) {
            const queue = [[start]];
            const visited = new Set([start]);
            
            while (queue.length > 0) {
                const path = queue.shift();
                const current = path[path.length - 1];
                
                if (current === end) {
                    return path;
                }
                
                const neighbors = routes
                    .filter(r => r.from === current || r.to === current)
                    .map(r => r.from === current ? r.to : r.from)
                    .filter(n => !visited.has(n));
                
                for (const neighbor of neighbors) {
                    visited.add(neighbor);
                    queue.push([...path, neighbor]);
                }
            }
            
            return null;
        }
        
        function clearRoute() {
            plannedRoute = [];
            updateRouteDisplay();
        }
        
        function findRoute(from, to) {
            let route = routes.find(r => 
                (r.from === from && r.to === to) || 
                (r.from === to && r.to === from)
            );
            
            if (route && route.from !== from) {
                return {...route, from: to, to: from};
            }
            
            return route;
        }
        
        function updateRouteDisplay() {
            // Update 2D circles
            Object.entries(routeCircles).forEach(([name, circle]) => {
                circle.classList.remove('selected', 'in-route');
                if (plannedRoute.includes(name)) {
                    if (name === plannedRoute[plannedRoute.length - 1]) {
                        circle.classList.add('selected');
                    } else {
                        circle.classList.add('in-route');
                    }
                }
            });
            
            Object.values(routeLines).forEach(line => {
                line.classList.remove('active');
            });
            
            for (let i = 0; i < plannedRoute.length - 1; i++) {
                const key = `${plannedRoute[i]}-${plannedRoute[i + 1]}`;
                if (routeLines[key]) {
                    routeLines[key].classList.add('active');
                }
            }

            // Update 3D if initialized
            if (scene3D) {
                update3DRouteDisplay();
            }
            
            const routeContent = document.getElementById('route-content');
            
            if (plannedRoute.length === 0) {
                routeContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">✧</div>
                        <div class="empty-state-text">Click stations on the map to plan your route</div>
                    </div>
                `;
                return;
            }
            
            let html = '<div class="route-display">';
            plannedRoute.forEach((station, idx) => {
                html += `
                    <div class="route-stop">
                        <div class="stop-number">${idx + 1}</div>
                        <div class="stop-name">${station}</div>
                    </div>
                `;
                if (idx < plannedRoute.length - 1) {
                    html += '<div class="stop-arrow">→</div>';
                }
            });
            html += '</div>';
            
            let totalProper = 0;
            let totalTau = 0;
            let totalFdr = 0;
            let legs = [];
            
            for (let i = 0; i < plannedRoute.length - 1; i++) {
                const route = findRoute(plannedRoute[i], plannedRoute[i + 1]);
                if (route) {
                    totalProper += route.proper;
                    totalTau += route.tau || 0;
                    totalFdr += route.fdr || 0;
                    legs.push({
                        from: plannedRoute[i],
                        to: plannedRoute[i + 1],
                        ...route
                    });
                } else {
                    legs.push({
                        from: plannedRoute[i],
                        to: plannedRoute[i + 1],
                        noRoute: true
                    });
                }
            }
            
            if (plannedRoute.length > 1) {
                html += '<div class="totals-section">';
                html += `
                    <div class="total-box">
                        <div class="total-label">Total Proper Time</div>
                        <div class="total-value">${totalProper.toFixed(1)}<span class="total-unit">days</span></div>
                    </div>
                `;
                
                if (totalTau > 0) {
                    html += `
                        <div class="total-box">
                            <div class="total-label">Total Tau Time</div>
                            <div class="total-value">${totalTau.toFixed(1)}<span class="total-unit">hours</span></div>
                        </div>
                    `;
                }
                
                if (totalFdr > 0) {
                    html += `
                        <div class="total-box">
                            <div class="total-label">Total FDR Burn</div>
                            <div class="total-value">${totalFdr.toFixed(1)}<span class="total-unit">hours</span></div>
                        </div>
                    `;
                }
                html += '</div>';
                
                html += '<div class="leg-details">';
                html += '<h3>ROUTE SEGMENTS</h3>';
                legs.forEach((leg, idx) => {
                    if (leg.noRoute) {
                        html += `
                            <div class="leg-item" style="border-left-color: #ff6b6b;">
                                <div class="leg-route">${idx + 1}. ${leg.from} → ${leg.to}</div>
                                <div class="leg-times" style="color: #ff6b6b;">No direct route available</div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="leg-item">
                                <div class="leg-route">${idx + 1}. ${leg.from} → ${leg.to}</div>
                                <div class="leg-times">
                                    <div class="leg-time">
                                        <span class="leg-time-label">Proper:</span>
                                        <span class="leg-time-value">${leg.proper.toFixed(1)}d</span>
                                    </div>
                        `;
                        if (leg.tau) {
                            html += `
                                    <div class="leg-time">
                                        <span class="leg-time-label">Tau:</span>
                                        <span class="leg-time-value">${leg.tau.toFixed(1)}h</span>
                                    </div>
                            `;
                        }
                        if (leg.fdr) {
                            html += `
                                    <div class="leg-time">
                                        <span class="leg-time-label">FDR:</span>
                                        <span class="leg-time-value">${leg.fdr.toFixed(1)}h</span>
                                    </div>
                            `;
                        }
                        html += `
                                </div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
            }
            
            routeContent.innerHTML = html;
        }

        // ═══════════════════════════════════════════════════════════════
        // 3D VIEW SETUP
        // ═══════════════════════════════════════════════════════════════

        let scene3D, camera3D, renderer3D, controls3D;
        let stationMeshes3D = {};
        let routeLines3D = [];
        let labelSprites = [];
        let raycaster, mouse;
        let isInitialized3D = false;

        // Scaling function - compress distant systems
        function scalePosition(coords) {
            const scale = 2.5; // Base scale
            // Apply slight compression for far systems
            const distance = Math.sqrt(coords[0]**2 + coords[1]**2 + coords[2]**2);
            const compressionFactor = distance > 30 ? 0.7 + (30 / distance) * 0.3 : 1;
            return [
                coords[0] * scale * compressionFactor,
                coords[1] * scale * compressionFactor,
                coords[2] * scale * compressionFactor
            ];
        }

        function init3D() {
            if (isInitialized3D) return;
            
            const container = document.getElementById('three-container');
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 600;

            // Scene
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x000008);
            scene3D.fog = new THREE.FogExp2(0x000008, 0.003);

            // Camera
            camera3D = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
            camera3D.position.set(100, 80, 120);
            camera3D.lookAt(0, 0, 0);

            // Renderer
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(width, height);
            renderer3D.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer3D.domElement);

            // Orbit Controls (simplified implementation)
            setupOrbitControls();

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Add grid helper
            const gridHelper = new THREE.GridHelper(200, 20, 0x1a1a3a, 0x0a0a1a);
            gridHelper.position.y = -50;
            scene3D.add(gridHelper);

            // Add axes helper
            createAxesLabels();

            // Create stations
            Object.entries(stations3D).forEach(([name, data]) => {
                const scaledPos = scalePosition(data.coords);
                
                // Station sphere
                const geometry = new THREE.SphereGeometry(name === 'Sol' ? 3 : 1.5, 32, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: factionColors[data.faction],
                    transparent: true,
                    opacity: 0.9
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.set(scaledPos[0], scaledPos[1], scaledPos[2]);
                sphere.userData = { name, ...data };
                
                // Glow effect
                const glowGeometry = new THREE.SphereGeometry(name === 'Sol' ? 4.5 : 2.5, 32, 32);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: factionColors[data.faction],
                    transparent: true,
                    opacity: 0.2
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                sphere.add(glow);

                scene3D.add(sphere);
                stationMeshes3D[name] = sphere;

                // Label sprite
                const label = createTextSprite(name, data.pop);
                label.position.set(scaledPos[0], scaledPos[1] + 5, scaledPos[2]);
                scene3D.add(label);
                labelSprites.push(label);
            });

            // Create route lines
            routes.forEach(route => {
                const fromPos = scalePosition(stations3D[route.from].coords);
                const toPos = scalePosition(stations3D[route.to].coords);
                
                const material = new THREE.LineBasicMaterial({
                    color: routeTypeColors[route.type],
                    transparent: true,
                    opacity: route.type === 'inter' ? 0.3 : 0.4,
                    linewidth: 1
                });

                const points = [
                    new THREE.Vector3(fromPos[0], fromPos[1], fromPos[2]),
                    new THREE.Vector3(toPos[0], toPos[1], toPos[2])
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(geometry, material);
                line.userData = { from: route.from, to: route.to, type: route.type };
                
                scene3D.add(line);
                routeLines3D.push(line);
            });

            // Create star system cluster indicators
            Object.entries(starSystems).forEach(([systemName, systemData]) => {
                const centerPos = scalePosition(systemData.center);
                
                // Create a ring/torus around the system
                const torusGeometry = new THREE.TorusGeometry(8, 0.15, 8, 32);
                const torusMaterial = new THREE.MeshBasicMaterial({
                    color: systemData.color,
                    transparent: true,
                    opacity: 0.3
                });
                const torus = new THREE.Mesh(torusGeometry, torusMaterial);
                torus.position.set(centerPos[0], centerPos[1], centerPos[2]);
                // Tilt the ring to be more visible from typical camera angles
                torus.rotation.x = Math.PI / 3;
                torus.rotation.z = Math.PI / 6;
                scene3D.add(torus);

                // Create dashed connecting lines between system members
                const stationPositions = systemData.stations.map(name => 
                    scalePosition(stations3D[name].coords)
                );
                
                if (stationPositions.length >= 2) {
                    // Line between Proxima and Rigil
                    const orbitLineMaterial = new THREE.LineDashedMaterial({
                        color: systemData.color,
                        transparent: true,
                        opacity: 0.5,
                        dashSize: 1,
                        gapSize: 0.5
                    });
                    
                    const orbitPoints = stationPositions.map(pos => 
                        new THREE.Vector3(pos[0], pos[1], pos[2])
                    );
                    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
                    const orbitLine = new THREE.Line(orbitGeometry, orbitLineMaterial);
                    orbitLine.computeLineDistances(); // Required for dashed lines
                    scene3D.add(orbitLine);
                }

                // Add system label
                const systemLabel = createSystemLabel(systemData.label);
                systemLabel.position.set(centerPos[0], centerPos[1] + 12, centerPos[2]);
                scene3D.add(systemLabel);
                labelSprites.push(systemLabel);
            });

            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene3D.add(ambientLight);

            // Point light at Sol
            const solLight = new THREE.PointLight(0xffffdd, 1, 200);
            solLight.position.set(0, 0, 0);
            scene3D.add(solLight);

            // Event listeners
            container.addEventListener('mousemove', onMouseMove3D);
            container.addEventListener('click', onClick3D);
            window.addEventListener('resize', onWindowResize3D);

            isInitialized3D = true;
            animate3D();
        }

        function createTextSprite(name, pop) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'Bold 24px Orbitron, sans-serif';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(name, 128, 28);
            
            context.font = '16px VT323, monospace';
            context.fillStyle = '#00ffff';
            context.fillText(pop + 'M', 128, 50);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 5, 1);
            
            return sprite;
        }

        function createSystemLabel(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 48;
            
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw a subtle background pill
            context.fillStyle = 'rgba(167, 139, 250, 0.15)';
            context.strokeStyle = 'rgba(167, 139, 250, 0.4)';
            context.lineWidth = 2;
            context.beginPath();
            context.roundRect(20, 8, 216, 32, 16);
            context.fill();
            context.stroke();
            
            context.font = '18px VT323, monospace';
            context.fillStyle = '#a78bfa';
            context.textAlign = 'center';
            context.fillText(text, 128, 30);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: 0.85
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(18, 4, 1);
            
            return sprite;
        }

        function createAxesLabels() {
            // X axis (cyan)
            const xAxisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-100, -50, 0),
                new THREE.Vector3(100, -50, 0)
            ]);
            const xAxisMat = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
            scene3D.add(new THREE.Line(xAxisGeo, xAxisMat));

            // Y axis (purple) - vertical
            const yAxisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -100, 0),
                new THREE.Vector3(0, 100, 0)
            ]);
            const yAxisMat = new THREE.LineBasicMaterial({ color: 0xbf00ff, opacity: 0.3, transparent: true });
            scene3D.add(new THREE.Line(yAxisGeo, yAxisMat));

            // Z axis (green)
            const zAxisGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -50, -100),
                new THREE.Vector3(0, -50, 100)
            ]);
            const zAxisMat = new THREE.LineBasicMaterial({ color: 0x00ff88, opacity: 0.3, transparent: true });
            scene3D.add(new THREE.Line(zAxisGeo, zAxisMat));
        }

        // Simple orbit controls implementation
        function setupOrbitControls() {
            const container = document.getElementById('three-container');
            let isDragging = false;
            let isPanning = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            // Spherical coordinates
            let theta = Math.PI / 4;
            let phi = Math.PI / 3;
            let radius = 180;
            const target = new THREE.Vector3(0, 0, 0);

            function updateCameraPosition() {
                camera3D.position.x = target.x + radius * Math.sin(phi) * Math.cos(theta);
                camera3D.position.y = target.y + radius * Math.cos(phi);
                camera3D.position.z = target.z + radius * Math.sin(phi) * Math.sin(theta);
                camera3D.lookAt(target);
            }

            container.addEventListener('mousedown', (e) => {
                if (e.button === 0) isDragging = true;
                if (e.button === 2) isPanning = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('mouseup', () => {
                isDragging = false;
                isPanning = false;
            });

            container.addEventListener('mouseleave', () => {
                isDragging = false;
                isPanning = false;
            });

            container.addEventListener('mousemove', (e) => {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                if (isDragging) {
                    theta -= deltaX * 0.01;
                    phi -= deltaY * 0.01;
                    phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                    updateCameraPosition();
                }

                if (isPanning) {
                    const panSpeed = 0.5;
                    const right = new THREE.Vector3();
                    const up = new THREE.Vector3();
                    camera3D.matrix.extractBasis(right, up, new THREE.Vector3());
                    target.addScaledVector(right, -deltaX * panSpeed);
                    target.addScaledVector(up, deltaY * panSpeed);
                    updateCameraPosition();
                }

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                radius *= 1 + e.deltaY * 0.001;
                radius = Math.max(50, Math.min(500, radius));
                updateCameraPosition();
            });

            container.addEventListener('contextmenu', (e) => e.preventDefault());

            updateCameraPosition();
        }

        function onMouseMove3D(event) {
            const container = document.getElementById('three-container');
            const rect = container.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera3D);
            const intersects = raycaster.intersectObjects(Object.values(stationMeshes3D));

            const tooltip = document.getElementById('tooltip-3d');
            
            if (intersects.length > 0) {
                const station = intersects[0].object;
                const data = station.userData;
                
                tooltip.querySelector('.tooltip-name').textContent = data.name;
                tooltip.querySelector('.tooltip-pop').textContent = `Population: ${data.pop}M`;
                tooltip.querySelector('.tooltip-faction').textContent = data.faction;
                
                // Show system info if part of a multi-star system
                const systemDiv = tooltip.querySelector('.tooltip-system');
                if (data.system && data.systemRole) {
                    systemDiv.textContent = `${starSystems[data.system].label} • ${data.systemRole}`;
                    systemDiv.style.display = 'block';
                } else {
                    systemDiv.style.display = 'none';
                }
                
                tooltip.style.display = 'block';
                tooltip.style.left = event.clientX + 15 + 'px';
                tooltip.style.top = event.clientY + 15 + 'px';
                
                container.style.cursor = 'pointer';
            } else {
                tooltip.style.display = 'none';
                container.style.cursor = 'grab';
            }
        }

        function onClick3D(event) {
            raycaster.setFromCamera(mouse, camera3D);
            const intersects = raycaster.intersectObjects(Object.values(stationMeshes3D));

            if (intersects.length > 0) {
                const stationName = intersects[0].object.userData.name;
                addStationToRoute(stationName);
            }
        }

        function update3DRouteDisplay() {
            // Reset all station materials
            Object.entries(stationMeshes3D).forEach(([name, mesh]) => {
                const faction = stations3D[name].faction;
                mesh.material.color.setHex(factionColors[faction]);
                mesh.material.opacity = 0.9;
                mesh.scale.set(1, 1, 1);
            });

            // Reset all route lines
            routeLines3D.forEach(line => {
                line.material.opacity = line.userData.type === 'inter' ? 0.3 : 0.4;
            });

            // Highlight selected stations
            plannedRoute.forEach((name, idx) => {
                const mesh = stationMeshes3D[name];
                if (idx === plannedRoute.length - 1) {
                    mesh.material.color.setHex(0x00ffff);
                    mesh.scale.set(1.5, 1.5, 1.5);
                } else {
                    mesh.material.color.setHex(0xbf00ff);
                    mesh.scale.set(1.3, 1.3, 1.3);
                }
            });

            // Highlight active routes
            for (let i = 0; i < plannedRoute.length - 1; i++) {
                const from = plannedRoute[i];
                const to = plannedRoute[i + 1];
                
                routeLines3D.forEach(line => {
                    if ((line.userData.from === from && line.userData.to === to) ||
                        (line.userData.from === to && line.userData.to === from)) {
                        line.material.opacity = 1;
                        line.material.color.setHex(0x00ffff);
                    }
                });
            }
        }

        function onWindowResize3D() {
            if (!isInitialized3D) return;
            const container = document.getElementById('three-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            camera3D.aspect = width / height;
            camera3D.updateProjectionMatrix();
            renderer3D.setSize(width, height);
        }

        function animate3D() {
            if (!isInitialized3D) return;
            requestAnimationFrame(animate3D);
            
            // Rotate labels to face camera
            labelSprites.forEach(sprite => {
                sprite.quaternion.copy(camera3D.quaternion);
            });

            // Pulse glow effect on Sol
            if (stationMeshes3D['Sol']) {
                const glow = stationMeshes3D['Sol'].children[0];
                if (glow) {
                    const pulse = 0.15 + Math.sin(Date.now() * 0.002) * 0.05;
                    glow.material.opacity = pulse;
                }
            }

            renderer3D.render(scene3D, camera3D);
        }

        // ═══════════════════════════════════════════════════════════════
        // MODE SWITCHING
        // ═══════════════════════════════════════════════════════════════

        let currentMode = '2d';

        function setMode(mode) {
            currentMode = mode;
            
            const btn2D = document.getElementById('btn-2d');
            const btn3D = document.getElementById('btn-3d');
            const svgMap = document.getElementById('transit-map');
            const threeContainer = document.getElementById('three-container');
            const controlsHint = document.getElementById('controls-hint');

            if (mode === '2d') {
                btn2D.classList.add('active');
                btn3D.classList.remove('active');
                svgMap.classList.remove('hidden');
                threeContainer.classList.remove('active');
                controlsHint.style.display = 'none';
            } else {
                btn2D.classList.remove('active');
                btn3D.classList.add('active');
                svgMap.classList.add('hidden');
                threeContainer.classList.add('active');
                controlsHint.style.display = 'block';
                
                if (!isInitialized3D) {
                    init3D();
                } else {
                    onWindowResize3D();
                    update3DRouteDisplay();
                }
            }

            // Glitch effect on mode change
            document.body.classList.add('glitch');
            setTimeout(() => document.body.classList.remove('glitch'), 150);
        }

        // Initialize with 2D mode
        updateRouteDisplay();
    </script>
        <!-- Optional: Replace milkyway with procedural acidburn background -->
    <script src="acidburn-galaxy.js"></script>
    <script src="nav-menu.js"></script>
</body>
</html>

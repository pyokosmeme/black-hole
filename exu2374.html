<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inhabited Space - 2370 SolUT</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&family=Space+Mono:wght@400;700&family=VT323&display=swap" rel="stylesheet">
    
    <!-- Black hole dependencies -->
    <script src="js-libs/jquery-2.1.4.min.js"></script>
    <script src="js-libs/three.min.js"></script>
    <script src="js-libs/OrbitControls.js"></script>
    <script src="js-libs/Detector.js"></script>
    <script src="js-libs/stats.min.js"></script>
    <script src="js-libs/ShaderLoader.min.js"></script>
    <script src="js-libs/mustache.min.js"></script>
    <script src="js-libs/dat.gui.min.js"></script>
    <script src="three-js-monkey-patch.js"></script>
    
    <!-- Black hole dependencies -->
    <script src="js-libs/jquery-2.1.4.min.js"></script>
    <script src="js-libs/three.min.js"></script>
    <script src="js-libs/OrbitControls.js"></script>
    <script src="js-libs/Detector.js"></script>
    <script src="js-libs/stats.min.js"></script>
    <script src="js-libs/ShaderLoader.min.js"></script>
    <script src="js-libs/mustache.min.js"></script>
    <script src="js-libs/dat.gui.min.js"></script>
    <script src="three-js-monkey-patch.js"></script>
    
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ACIDBURN TRANSIT MAP
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --cyan: #00ffff;
            --purple: #bf00ff;
            --magenta: #ff00ff;
            --green: #00ff88;
            --pink: #ff0099;
            --dark: #000000;
            --panel: rgba(5, 5, 15, 0.85);
            
            /* Faction colors */
            --uplb: #4a9eff;
            --swi: #51cf66;
            --hw: #a78bfa;
            --inter: #fbbf24;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            min-height: 100vh;
            background: var(--dark);
            color: #fff;
            font-family: 'Share Tech Mono', monospace;
            overflow-x: hidden;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BLACK HOLE BACKGROUND
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #blackhole-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        #blackhole-container canvas {
            display: block;
        }

        /* Hide original black hole UI */
        .info, .link-bar, #hint-text, .dg.ac, #stats {
            display: none !important;
        }

        /* Scanlines */
        body::after {
            content: '';
            position: fixed;
            inset: 0;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.1) 0px,
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 3px
            );
            pointer-events: none;
            z-index: 10000;
            animation: scan 0.1s linear infinite;
        }

        @keyframes scan {
            to { transform: translateY(6px); }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           HEADER BAR - MAXIMUM TEXTURE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            overflow: hidden;
        }

        .header-bar::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                repeating-linear-gradient(-60deg, var(--purple) 0px, var(--purple) 6px, transparent 6px, transparent 12px),
                repeating-linear-gradient(60deg, var(--cyan) 0px, var(--cyan) 4px, transparent 4px, transparent 14px),
                repeating-linear-gradient(-45deg, rgba(255, 0, 153, 0.5) 0px, rgba(255, 0, 153, 0.5) 2px, transparent 2px, transparent 6px),
                repeating-linear-gradient(75deg, rgba(0, 255, 255, 0.4) 0px, rgba(0, 255, 255, 0.4) 3px, transparent 3px, transparent 9px),
                linear-gradient(90deg, var(--purple), var(--cyan), var(--magenta), var(--cyan), var(--purple));
            z-index: -2;
        }

        .header-texture {
            position: absolute;
            inset: 0;
            background:
                repeating-linear-gradient(90deg, transparent 0px, transparent 2px, rgba(0,0,0,0.2) 2px, rgba(0,0,0,0.2) 4px),
                repeating-linear-gradient(0deg, transparent 0px, transparent 3px, rgba(255,255,255,0.08) 3px, rgba(255,255,255,0.08) 4px);
            z-index: -1;
            mix-blend-mode: overlay;
        }

        .header-bar::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--cyan), var(--purple), var(--cyan));
            box-shadow: 0 0 15px var(--cyan);
        }

        .header-title {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            font-size: 20px;
            color: #000;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            letter-spacing: 3px;
            z-index: 10;
        }

        .header-subtitle {
            font-family: 'VT323', monospace;
            font-size: 16px;
            color: rgba(0,0,0,0.8);
            letter-spacing: 2px;
            z-index: 10;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN CONTENT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .container {
            position: relative;
            z-index: 10;
            padding: 80px 20px 40px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 20px;
            min-height: calc(100vh - 140px);
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAP CONTAINER
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        #map-container {
            background: var(--panel);
            border: 3px solid transparent;
            border-image: linear-gradient(135deg, var(--purple), var(--cyan), var(--purple)) 1;
            position: relative;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        #map-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: 
                repeating-linear-gradient(-55deg, var(--purple) 0px, var(--purple) 5px, transparent 5px, transparent 10px),
                repeating-linear-gradient(55deg, var(--cyan) 0px, var(--cyan) 4px, transparent 4px, transparent 12px),
                linear-gradient(90deg, var(--purple), var(--cyan), var(--purple));
            z-index: 10;
        }

        #transit-map {
            width: 100%;
            height: 100%;
            min-height: 600px;
            display: block;
        }

        /* SVG Styles */
        .route-line {
            stroke-width: 3;
            opacity: 0.4;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .route-line.active {
            opacity: 1;
            stroke-width: 5;
            filter: drop-shadow(0 0 8px currentColor);
        }

        .uplb-route { stroke: var(--uplb); }
        .swi-route { stroke: var(--swi); }
        .hw-route { stroke: var(--hw); }
        .inter-route { stroke: var(--inter); stroke-dasharray: 8, 4; }

        .station-group {
            cursor: pointer;
        }

        .station-group:hover .station-circle {
            filter: drop-shadow(0 0 15px currentColor);
            stroke-width: 4;
        }

        .station-group:hover .station-label {
            fill: var(--cyan);
        }

        .station-hit-area {
            fill: transparent;
            cursor: pointer;
        }

        .station-circle {
            transition: all 0.15s ease;
            pointer-events: none;
            fill: #0a0a1a;
            stroke-width: 3;
        }

        .station-circle.faction-uplb { stroke: var(--uplb); }
        .station-circle.faction-swi { stroke: var(--swi); }
        .station-circle.faction-hw { stroke: var(--hw); }

        .station-circle.selected {
            fill: var(--cyan) !important;
            stroke: var(--cyan) !important;
            filter: drop-shadow(0 0 15px var(--cyan));
        }

        .station-circle.in-route {
            fill: var(--purple) !important;
            stroke: var(--purple) !important;
            filter: drop-shadow(0 0 10px var(--purple));
        }

        .station-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            font-weight: 700;
            fill: #fff;
            pointer-events: none;
            transition: fill 0.15s ease;
        }

        .station-sublabel {
            font-family: 'VT323', monospace;
            font-size: 12px;
            fill: var(--cyan);
            opacity: 0.8;
            pointer-events: none;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--panel);
            border: 2px solid var(--purple);
            padding: 15px 20px;
            backdrop-filter: blur(5px);
        }

        .legend h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--purple);
            letter-spacing: 2px;
            margin-bottom: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
        }

        .legend-line {
            width: 30px;
            height: 3px;
        }

        .legend-line.uplb-route { background: var(--uplb); }
        .legend-line.swi-route { background: var(--swi); }
        .legend-line.hw-route { background: var(--hw); }
        .legend-line.inter-route { 
            background: repeating-linear-gradient(90deg, var(--inter) 0px, var(--inter) 8px, transparent 8px, transparent 12px);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ROUTE PLANNER PANEL
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .route-planner {
            background: var(--panel);
            border: 3px solid transparent;
            border-image: linear-gradient(135deg, var(--cyan), var(--purple)) 1;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(10px);
            max-height: calc(100vh - 120px);
            overflow: hidden;
        }

        .route-planner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: 
                repeating-linear-gradient(-55deg, var(--cyan) 0px, var(--cyan) 5px, transparent 5px, transparent 10px),
                repeating-linear-gradient(55deg, var(--purple) 0px, var(--purple) 4px, transparent 4px, transparent 12px),
                linear-gradient(90deg, var(--cyan), var(--purple), var(--cyan));
        }

        .planner-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 20px 15px;
            border-bottom: 1px solid rgba(191, 0, 255, 0.3);
        }

        .planner-header h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            color: var(--cyan);
            letter-spacing: 3px;
        }

        .clear-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            padding: 8px 15px;
            background: transparent;
            border: 2px solid var(--pink);
            color: var(--pink);
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            background: var(--pink);
            color: #000;
            box-shadow: 0 0 20px var(--pink);
        }

        #route-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Scrollbar */
        #route-content::-webkit-scrollbar {
            width: 6px;
        }

        #route-content::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
        }

        #route-content::-webkit-scrollbar-thumb {
            background: var(--purple);
            border-radius: 3px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            filter: grayscale(0.5);
        }

        .empty-state-text {
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            line-height: 1.6;
        }

        /* Route Display */
        .route-display {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }

        .route-stop {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--cyan);
            padding: 6px 12px;
            border-radius: 3px;
        }

        .stop-number {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--purple);
            background: rgba(191, 0, 255, 0.2);
            padding: 2px 6px;
            border-radius: 2px;
        }

        .stop-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--cyan);
        }

        .stop-arrow {
            color: var(--purple);
            font-size: 16px;
        }

        /* Totals */
        .totals-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 12px;
            margin-bottom: 25px;
        }

        .total-box {
            background: rgba(191, 0, 255, 0.1);
            border: 1px solid var(--purple);
            padding: 18px 12px;
            text-align: center;
        }

        .total-label {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 1px;
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .total-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            color: var(--cyan);
            text-shadow: 0 0 10px var(--cyan);
        }

        .total-unit {
            font-size: 11px;
            color: rgba(255,255,255,0.5);
            margin-left: 4px;
        }

        /* Leg Details */
        .leg-details h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 11px;
            color: var(--purple);
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .leg-item {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--cyan);
            padding: 12px 15px;
            margin-bottom: 10px;
        }

        .leg-route {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: #fff;
            margin-bottom: 8px;
        }

        .leg-times {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .leg-time {
            font-size: 11px;
        }

        .leg-time-label {
            color: rgba(255,255,255,0.5);
        }

        .leg-time-value {
            color: var(--green);
            font-family: 'VT323', monospace;
            font-size: 14px;
            margin-left: 5px;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FOOTER
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        .footer {
            text-align: center;
            padding: 30px 20px;
            margin-top: 20px;
        }

        .footer p {
            font-size: 12px;
            color: rgba(255,255,255,0.3);
        }

        .footer a {
            color: var(--cyan);
            text-decoration: none;
            border-bottom: 1px solid var(--purple);
            transition: all 0.2s ease;
        }

        .footer a:hover {
            color: var(--purple);
            border-color: var(--cyan);
            text-shadow: 0 0 10px var(--purple);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           GLITCH EFFECT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        body.glitch {
            animation: glitchEffect 0.15s linear;
        }

        @keyframes glitchEffect {
            0%, 100% { transform: translate(0); filter: hue-rotate(0); }
            25% { transform: translate(-2px, 1px); filter: hue-rotate(90deg); }
            50% { transform: translate(2px, -1px); filter: hue-rotate(180deg); }
            75% { transform: translate(-1px, -2px); filter: hue-rotate(270deg); }
        }
    </style>
</head>
<body>
    <!-- Black Hole Background -->
    <div id="blackhole-container"></div>
    
    <!-- Original black hole UI elements (hidden) -->
    <div id="hint-text" class="hidden-phone initially-hidden"></div>
    <div class="info"><div id="loader">Loading...</div></div>
    <div class="link-bar"></div>

    <!-- Header -->
    <header class="header-bar">
        <div class="header-texture"></div>
        <div class="header-title">INHABITED SPACE TRANSIT NETWORK</div>
        <div class="header-subtitle">K-Tube Route Planner â€¢ ERR-AL Drive â€¢ 2370 SolUT</div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="main-content">
            <div id="map-container">
                <svg id="transit-map" viewBox="0 0 1600 1000"></svg>
                
                <div class="legend">
                    <h3>FACTION ROUTES</h3>
                    <div class="legend-item">
                        <div class="legend-line uplb-route"></div>
                        <span>UPLB</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line swi-route"></div>
                        <span>SWI</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line hw-route"></div>
                        <span>Homeworlds</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line inter-route"></div>
                        <span>Inter-faction</span>
                    </div>
                </div>
            </div>
            
            <div class="route-planner">
                <div class="planner-header">
                    <h2>ROUTE PLANNER</h2>
                    <button class="clear-btn" onclick="clearRoute()">CLEAR ROUTE</button>
                </div>
                
                <div id="route-content">
                    <div class="empty-state">
                        <div class="empty-state-icon">âœ§</div>
                        <div class="empty-state-text">Click stations on the map to plan your route</div>
                    </div>
                </div>
            </div>
        </div>

        <footer class="footer">
            <p>transit data current as of 2370.127 SolUT ;; <a href="#">network status: nominal</a></p>
        </footer>
    </div>

    <!-- Black hole shaders -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4(position, 1.0);
        }
    </script>
    <script data-src="raytracer.glsl" data-name="raytracer" type="x-shader/x-fragment"></script>

    <!-- Black hole renderer -->
    <script>
        "use strict";

        if (!Detector.webgl) Detector.addGetWebGLMessage();

        function Observer() {
            this.position = new THREE.Vector3(10, 0, 0);
            this.velocity = new THREE.Vector3(0, 1, 0);
            this.orientation = new THREE.Matrix3();
            this.time = 0.0;
        }

        Observer.prototype.orbitalFrame = function () {
            var orbital_y = new THREE.Vector3()
                .subVectors(
                    this.velocity.clone().normalize().multiplyScalar(4.0),
                    this.position
                )
                .normalize();
            var orbital_z = new THREE.Vector3()
                .crossVectors(this.position, orbital_y)
                .normalize();
            var orbital_x = new THREE.Vector3().crossVectors(orbital_y, orbital_z);
            return new THREE.Matrix4()
                .makeBasis(orbital_x, orbital_y, orbital_z)
                .linearPart();
        };

        Observer.prototype.move = function (dt) {
            dt *= shader.parameters.time_scale;
            var r, v = 0;

            if (shader.parameters.observer.motion) {
                r = shader.parameters.observer.distance;
                v = 1.0 / Math.sqrt(2.0 * (r - 1.0));
                var ang_vel = v / r;
                var angle = this.time * ang_vel;
                var s = Math.sin(angle), c = Math.cos(angle);

                this.position.set(c * r, s * r, 0);
                this.velocity.set(-s * v, c * v, 0);

                var alpha = degToRad(shader.parameters.observer.orbital_inclination);
                var orbit_coords = new THREE.Matrix4().makeRotationY(alpha);
                this.position.applyMatrix4(orbit_coords);
                this.velocity.applyMatrix4(orbit_coords);
            } else {
                r = this.position.length();
            }

            if (shader.parameters.gravitational_time_dilation) {
                dt = Math.sqrt((dt * dt * (1.0 - v * v)) / (1 - 1.0 / r));
            }
            this.time += dt;
        };

        var container, stats;
        var camera, scene, renderer, cameraControls, shader = null;
        var observer = new Observer();

        function Shader(mustacheTemplate) {
            this.parameters = {
                n_steps: 100,
                quality: "medium",
                accretion_disk: true,
                planet: { enabled: false, distance: 7.0, radius: 0.4 },
                lorentz_contraction: true,
                gravitational_time_dilation: true,
                aberration: true,
                beaming: true,
                doppler_shift: true,
                light_travel_time: true,
                time_scale: 0.5,
                observer: { motion: true, distance: 15.0, orbital_inclination: -15 },
                planetEnabled: function () {
                    return this.planet.enabled && this.quality !== "fast";
                },
                observerMotion: function () {
                    return this.observer.motion;
                },
            };
            var that = this;
            this.needsUpdate = false;
            this.hasMovingParts = function () {
                return this.parameters.planet.enabled || this.parameters.observer.motion;
            };
            this.compile = function () {
                return Mustache.render(mustacheTemplate, that.parameters);
            };
        }

        function degToRad(a) {
            return (Math.PI * a) / 180.0;
        }

        (function () {
            var textures = {};

            function whenLoaded() {
                init(textures);
                $("#loader").hide();
                animate();
            }

            function checkLoaded() {
                if (shader === null) return;
                for (var key in textures) if (textures[key] === null) return;
                whenLoaded();
            }

            SHADER_LOADER.load(function (shaders) {
                shader = new Shader(shaders.raytracer.fragment);
                checkLoaded();
            });

            var texLoader = new THREE.TextureLoader();
            function loadTexture(symbol, filename, interpolation) {
                textures[symbol] = null;
                texLoader.load(filename, function (tex) {
                    tex.magFilter = interpolation;
                    tex.minFilter = interpolation;
                    textures[symbol] = tex;
                    checkLoaded();
                });
            }

            loadTexture("galaxy", "img/milkyway.jpg", THREE.NearestFilter);
            loadTexture("spectra", "img/spectra.png", THREE.LinearFilter);
            loadTexture("moon", "img/beach-ball.png", THREE.LinearFilter);
            loadTexture("stars", "img/stars.png", THREE.LinearFilter);
            loadTexture("accretion_disk", "img/accretion-disk.png", THREE.LinearFilter);
        })();

        var updateUniforms;

        function init(textures) {
            container = document.getElementById("blackhole-container");

            scene = new THREE.Scene();
            var geometry = new THREE.PlaneBufferGeometry(2, 2);

            var uniforms = {
                time: { type: "f", value: 0 },
                resolution: { type: "v2", value: new THREE.Vector2() },
                cam_pos: { type: "v3", value: new THREE.Vector3() },
                cam_x: { type: "v3", value: new THREE.Vector3() },
                cam_y: { type: "v3", value: new THREE.Vector3() },
                cam_z: { type: "v3", value: new THREE.Vector3() },
                cam_vel: { type: "v3", value: new THREE.Vector3() },
                planet_distance: { type: "f" },
                planet_radius: { type: "f" },
                star_texture: { type: "t", value: textures.stars },
                accretion_disk_texture: { type: "t", value: textures.accretion_disk },
                galaxy_texture: { type: "t", value: textures.galaxy },
                planet_texture: { type: "t", value: textures.moon },
                spectrum_texture: { type: "t", value: textures.spectra },
            };

            updateUniforms = function () {
                uniforms.planet_distance.value = shader.parameters.planet.distance;
                uniforms.planet_radius.value = shader.parameters.planet.radius;
                uniforms.resolution.value.x = renderer.domElement.width;
                uniforms.resolution.value.y = renderer.domElement.height;
                uniforms.time.value = observer.time;
                uniforms.cam_pos.value = observer.position;

                var e = observer.orientation.elements;
                uniforms.cam_x.value.set(e[0], e[1], e[2]);
                uniforms.cam_y.value.set(e[3], e[4], e[5]);
                uniforms.cam_z.value.set(e[6], e[7], e[8]);

                function setVec(target, value) {
                    uniforms[target].value.set(value.x, value.y, value.z);
                }
                setVec("cam_pos", observer.position);
                setVec("cam_vel", observer.velocity);
            };

            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: $("#vertex-shader").text(),
            });

            scene.updateShader = function () {
                material.fragmentShader = shader.compile();
                material.needsUpdate = true;
                shader.needsUpdate = true;
            };
            scene.updateShader();

            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 80000);
            initializeCamera(camera);

            updateCamera();
            onWindowResize();
            window.addEventListener("resize", onWindowResize, false);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (updateUniforms) updateUniforms();
        }

        function initializeCamera(camera) {
            var pitchAngle = 3.0, yawAngle = 0.0;
            camera.matrixWorldInverse.makeRotationX(degToRad(-pitchAngle));
            camera.matrixWorldInverse.multiply(new THREE.Matrix4().makeRotationY(degToRad(-yawAngle)));
            var m = camera.matrixWorldInverse.elements;
            camera.position.set(m[2], m[6], m[10]);
        }

        function updateCamera() {
            var m = camera.matrixWorldInverse.elements;
            var camera_matrix;

            if (shader.parameters.observer.motion) {
                camera_matrix = new THREE.Matrix3();
            } else {
                camera_matrix = observer.orientation;
            }

            camera_matrix.set(m[0], m[1], m[2], m[8], m[9], m[10], m[4], m[5], m[6]);

            if (shader.parameters.observer.motion) {
                observer.orientation = observer.orbitalFrame().multiply(camera_matrix);
            } else {
                var p = new THREE.Vector3(
                    camera_matrix.elements[6],
                    camera_matrix.elements[7],
                    camera_matrix.elements[8]
                );
                var dist = shader.parameters.observer.distance;
                observer.position.set(-p.x * dist, -p.y * dist, -p.z * dist);
                observer.velocity.set(0, 0, 0);
            }
        }

        function frobeniusDistance(matrix1, matrix2) {
            var sum = 0.0;
            for (var i in matrix1.elements) {
                var diff = matrix1.elements[i] - matrix2.elements[i];
                sum += diff * diff;
            }
            return Math.sqrt(sum);
        }

        function animate() {
            requestAnimationFrame(animate);
            camera.updateMatrixWorld();
            camera.matrixWorldInverse.getInverse(camera.matrixWorld);

            if (shader.needsUpdate || shader.hasMovingParts() ||
                frobeniusDistance(camera.matrixWorldInverse, lastCameraMat) > 1e-10) {
                shader.needsUpdate = false;
                render();
                lastCameraMat = camera.matrixWorldInverse.clone();
            }
        }

        var lastCameraMat = new THREE.Matrix4().identity();

        var getFrameDuration = (function () {
            var lastTimestamp = new Date().getTime();
            return function () {
                var timestamp = new Date().getTime();
                var diff = (timestamp - lastTimestamp) / 1000.0;
                lastTimestamp = timestamp;
                return diff;
            };
        })();

        function render() {
            observer.move(getFrameDuration());
            if (shader.parameters.observer.motion) updateCamera();
            updateUniforms();
            renderer.render(scene, camera);
        }
    </script>

    <!-- Transit map + effects -->
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLITCH EFFECT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Random glitch effect
        setInterval(() => {
            if (Math.random() > 0.92) {
                document.body.classList.add('glitch');
                setTimeout(() => document.body.classList.remove('glitch'), 100);
            }
        }, 3000);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TRANSIT MAP LOGIC
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        const stations = {
            'Sol': {x: 800, y: 500, pop: 10440, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Gamov': {x: 950, y: 300, pop: 631, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Wolf': {x: 650, y: 250, pop: 432, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Luyten': {x: 500, y: 400, pop: 322, faction: 'UPLB', labelOffset: {x: -60, y: 0}},
            'Gowjin': {x: 500, y: 600, pop: 317, faction: 'UPLB', labelOffset: {x: -60, y: 0}},
            'Issetock': {x: 650, y: 700, pop: 283, faction: 'UPLB', labelOffset: {x: 0, y: 25}},
            'Nursia': {x: 950, y: 700, pop: 411, faction: 'UPLB', labelOffset: {x: 0, y: 25}},
            'Bakunawa': {x: 800, y: 150, pop: 215, faction: 'UPLB', labelOffset: {x: 0, y: -25}},
            'Vega': {x: 1150, y: 450, pop: 262, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Ya Ke': {x: 1400, y: 350, pop: 579, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Zi Wei Yuan': {x: 1400, y: 600, pop: 259, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Sipapu': {x: 1150, y: 700, pop: 254, faction: 'SWI', labelOffset: {x: 60, y: 0}},
            'Proxima': {x: 300, y: 700, pop: 397, faction: 'HW', labelOffset: {x: -60, y: 10}},
            'Rigil': {x: 400, y: 850, pop: 649, faction: 'HW', labelOffset: {x: 0, y: 25}},
            'Tartarus': {x: 250, y: 550, pop: 231, faction: 'HW', labelOffset: {x: -60, y: 0}},
            'Tau Ceti': {x: 550, y: 900, pop: 228, faction: 'HW', labelOffset: {x: 0, y: 25}},
            'Barnard': {x: 200, y: 850, pop: 455, faction: 'HW', labelOffset: {x: -60, y: 10}}
        };
        
        const routes = [
            {from: 'Sol', to: 'Gamov', proper: 55.58, tau: 6.0, fdr: 24, type: 'uplb'},
            {from: 'Sol', to: 'Wolf', proper: 19.17, tau: 1.92, fdr: 24, type: 'uplb'},
            {from: 'Sol', to: 'Luyten', proper: 17.32, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Gowjin', proper: 20.78, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Issetock', proper: 28.48, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Nursia', proper: 54.86, tau: null, fdr: null, type: 'uplb'},
            {from: 'Sol', to: 'Bakunawa', proper: 56.8, tau: null, fdr: null, type: 'uplb'},
            {from: 'Wolf', to: 'Gamov', proper: 31.55, tau: 3.128, fdr: 48, type: 'uplb'},
            {from: 'Vega', to: 'Ya Ke', proper: 87.23, tau: 12.25, fdr: 48, type: 'swi'},
            {from: 'Ya Ke', to: 'Sipapu', proper: 45.45, tau: 4.51, fdr: 24, type: 'swi'},
            {from: 'Gamov', to: 'Zi Wei Yuan', proper: 76.87, tau: 7.62, fdr: 24, type: 'swi'},
            {from: 'Zi Wei Yuan', to: 'Vega', proper: 82.87, tau: 8.22, fdr: 10, type: 'swi'},
            {from: 'Sol', to: 'Proxima', proper: 5.90, tau: 1.0, fdr: 20, type: 'hw'},
            {from: 'Sol', to: 'Rigil', proper: 5.90, tau: 1.0, fdr: 20, type: 'hw'},
            {from: 'Sol', to: 'Tartarus', proper: 15.13, tau: 1.51, fdr: 24, type: 'hw'},
            {from: 'Sol', to: 'Tau Ceti', proper: 16.5, tau: null, fdr: null, type: 'hw'},
            {from: 'Sol', to: 'Barnard', proper: 8.31, tau: null, fdr: null, type: 'hw'},
            {from: 'Sol', to: 'Vega', proper: 35.43, tau: 3.54, fdr: 10, type: 'inter'},
            {from: 'Wolf', to: 'Vega', proper: 21.69, tau: 2.99, fdr: 1, type: 'inter'},
            {from: 'Gamov', to: 'Vega', proper: 74.18, tau: 7.35, fdr: 48, type: 'inter'},
            {from: 'Gamov', to: 'Ya Ke', proper: 76.22, tau: 7.56, fdr: 20, type: 'inter'},
            {from: 'Gamov', to: 'Sipapu', proper: 40.48, tau: 4.01, fdr: 4, type: 'inter'},
            {from: 'Sol', to: 'Ya Ke', proper: 89.5, tau: 8.95, fdr: 48, type: 'inter'},
            {from: 'Sol', to: 'Zi Wei Yuan', proper: 94.48, tau: 9.45, fdr: 10, type: 'inter'},
            {from: 'Sol', to: 'Sipapu', proper: 56.97, tau: 5.697, fdr: 24, type: 'inter'}
        ];
        
        const svg = document.getElementById('transit-map');
        let plannedRoute = [];
        let routeCircles = {};
        let routeLines = {};
        
        // Draw routes
        routes.forEach((route, idx) => {
            const from = stations[route.from];
            const to = stations[route.to];
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', from.x);
            line.setAttribute('y1', from.y);
            line.setAttribute('x2', to.x);
            line.setAttribute('y2', to.y);
            line.classList.add('route-line', `${route.type}-route`);
            line.dataset.from = route.from;
            line.dataset.to = route.to;
            
            const key = `${route.from}-${route.to}`;
            routeLines[key] = line;
            const reverseKey = `${route.to}-${route.from}`;
            routeLines[reverseKey] = line;
            
            svg.appendChild(line);
        });
        
        // Draw stations
        Object.entries(stations).forEach(([name, data]) => {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.classList.add('station-group');
            
            // Large invisible hit area for easier clicking
            const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            hitArea.classList.add('station-hit-area');
            // Calculate hit area to cover station and label
            const hitX = data.x - 30 + Math.min(0, data.labelOffset.x);
            const hitY = data.y - 30 + Math.min(0, data.labelOffset.y);
            const hitW = 60 + Math.abs(data.labelOffset.x);
            const hitH = 60 + Math.abs(data.labelOffset.y);
            hitArea.setAttribute('x', hitX);
            hitArea.setAttribute('y', hitY);
            hitArea.setAttribute('width', hitW);
            hitArea.setAttribute('height', hitH);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.classList.add('station-circle', `faction-${data.faction.toLowerCase()}`);
            circle.setAttribute('cx', data.x);
            circle.setAttribute('cy', data.y);
            circle.setAttribute('r', 9);
            
            routeCircles[name] = circle;
            
            const labelX = data.x + data.labelOffset.x;
            const labelY = data.y + data.labelOffset.y;
            
            const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            label.classList.add('station-label');
            label.setAttribute('x', labelX);
            label.setAttribute('y', labelY);
            label.setAttribute('text-anchor', data.labelOffset.x > 0 ? 'start' : data.labelOffset.x < 0 ? 'end' : 'middle');
            label.textContent = name;
            
            const sublabelY = data.labelOffset.y < 0 ? labelY - 15 : labelY + 15;
            const sublabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            sublabel.classList.add('station-sublabel');
            sublabel.setAttribute('x', labelX);
            sublabel.setAttribute('y', sublabelY);
            sublabel.setAttribute('text-anchor', data.labelOffset.x > 0 ? 'start' : data.labelOffset.x < 0 ? 'end' : 'middle');
            sublabel.textContent = `${data.pop}M`;
            
            g.appendChild(hitArea);
            g.appendChild(circle);
            g.appendChild(label);
            g.appendChild(sublabel);
            svg.appendChild(g);
            
            g.addEventListener('click', (e) => {
                e.stopPropagation();
                addStationToRoute(name);
            });
        });
        
        function addStationToRoute(stationName) {
            if (plannedRoute.length > 0 && plannedRoute[plannedRoute.length - 1] === stationName) {
                return;
            }
            
            if (plannedRoute.length === 0) {
                plannedRoute.push(stationName);
            } else {
                const lastStation = plannedRoute[plannedRoute.length - 1];
                const directRoute = findRoute(lastStation, stationName);
                
                if (directRoute) {
                    plannedRoute.push(stationName);
                } else {
                    const path = findPath(lastStation, stationName);
                    if (path && path.length > 0) {
                        path.forEach(station => {
                            if (station !== lastStation) {
                                plannedRoute.push(station);
                            }
                        });
                    } else {
                        plannedRoute.push(stationName);
                    }
                }
            }
            
            updateRouteDisplay();
        }
        
        function findPath(start, end) {
            const queue = [[start]];
            const visited = new Set([start]);
            
            while (queue.length > 0) {
                const path = queue.shift();
                const current = path[path.length - 1];
                
                if (current === end) {
                    return path;
                }
                
                const neighbors = routes
                    .filter(r => r.from === current || r.to === current)
                    .map(r => r.from === current ? r.to : r.from)
                    .filter(n => !visited.has(n));
                
                for (const neighbor of neighbors) {
                    visited.add(neighbor);
                    queue.push([...path, neighbor]);
                }
            }
            
            return null;
        }
        
        function clearRoute() {
            plannedRoute = [];
            updateRouteDisplay();
        }
        
        function findRoute(from, to) {
            let route = routes.find(r => 
                (r.from === from && r.to === to) || 
                (r.from === to && r.to === from)
            );
            
            if (route && route.from !== from) {
                return {...route, from: to, to: from};
            }
            
            return route;
        }
        
        function updateRouteDisplay() {
            Object.entries(routeCircles).forEach(([name, circle]) => {
                circle.classList.remove('selected', 'in-route');
                if (plannedRoute.includes(name)) {
                    if (name === plannedRoute[plannedRoute.length - 1]) {
                        circle.classList.add('selected');
                    } else {
                        circle.classList.add('in-route');
                    }
                }
            });
            
            Object.values(routeLines).forEach(line => {
                line.classList.remove('active');
            });
            
            for (let i = 0; i < plannedRoute.length - 1; i++) {
                const key = `${plannedRoute[i]}-${plannedRoute[i + 1]}`;
                if (routeLines[key]) {
                    routeLines[key].classList.add('active');
                }
            }
            
            const routeContent = document.getElementById('route-content');
            
            if (plannedRoute.length === 0) {
                routeContent.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">ğŸš€</div>
                        <div class="empty-state-text">Click stations on the map to plan your route</div>
                    </div>
                `;
                return;
            }
            
            let html = '<div class="route-display">';
            plannedRoute.forEach((station, idx) => {
                html += `
                    <div class="route-stop">
                        <div class="stop-number">${idx + 1}</div>
                        <div class="stop-name">${station}</div>
                    </div>
                `;
                if (idx < plannedRoute.length - 1) {
                    html += '<div class="stop-arrow">â†’</div>';
                }
            });
            html += '</div>';
            
            let totalProper = 0;
            let totalTau = 0;
            let totalFdr = 0;
            let legs = [];
            
            for (let i = 0; i < plannedRoute.length - 1; i++) {
                const route = findRoute(plannedRoute[i], plannedRoute[i + 1]);
                if (route) {
                    totalProper += route.proper;
                    totalTau += route.tau || 0;
                    totalFdr += route.fdr || 0;
                    legs.push({
                        from: plannedRoute[i],
                        to: plannedRoute[i + 1],
                        ...route
                    });
                } else {
                    legs.push({
                        from: plannedRoute[i],
                        to: plannedRoute[i + 1],
                        noRoute: true
                    });
                }
            }
            
            if (plannedRoute.length > 1) {
                html += '<div class="totals-section">';
                html += `
                    <div class="total-box">
                        <div class="total-label">Total Proper Time</div>
                        <div class="total-value">${totalProper.toFixed(1)}<span class="total-unit">days</span></div>
                    </div>
                `;
                
                if (totalTau > 0) {
                    html += `
                        <div class="total-box">
                            <div class="total-label">Total Tau Time</div>
                            <div class="total-value">${totalTau.toFixed(1)}<span class="total-unit">hours</span></div>
                        </div>
                    `;
                }
                
                if (totalFdr > 0) {
                    html += `
                        <div class="total-box">
                            <div class="total-label">Total FDR Burn</div>
                            <div class="total-value">${totalFdr.toFixed(1)}<span class="total-unit">hours</span></div>
                        </div>
                    `;
                }
                html += '</div>';
                
                html += '<div class="leg-details">';
                html += '<h3>ROUTE SEGMENTS</h3>';
                legs.forEach((leg, idx) => {
                    if (leg.noRoute) {
                        html += `
                            <div class="leg-item" style="border-left-color: #ff6b6b;">
                                <div class="leg-route">${idx + 1}. ${leg.from} â†’ ${leg.to}</div>
                                <div class="leg-times" style="color: #ff6b6b;">No direct route available</div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="leg-item">
                                <div class="leg-route">${idx + 1}. ${leg.from} â†’ ${leg.to}</div>
                                <div class="leg-times">
                                    <div class="leg-time">
                                        <span class="leg-time-label">Proper:</span>
                                        <span class="leg-time-value">${leg.proper.toFixed(1)}d</span>
                                    </div>
                        `;
                        if (leg.tau) {
                            html += `
                                    <div class="leg-time">
                                        <span class="leg-time-label">Tau:</span>
                                        <span class="leg-time-value">${leg.tau.toFixed(1)}h</span>
                                    </div>
                            `;
                        }
                        if (leg.fdr) {
                            html += `
                                    <div class="leg-time">
                                        <span class="leg-time-label">FDR:</span>
                                        <span class="leg-time-value">${leg.fdr.toFixed(1)}h</span>
                                    </div>
                            `;
                        }
                        html += `
                                </div>
                            </div>
                        `;
                    }
                });
                html += '</div>';
            }
            
            routeContent.innerHTML = html;
        }
    </script>
    
    <!-- Optional: Replace milkyway with procedural acidburn background -->
    <script src="acidburn-galaxy.js"></script>
</body>
</html>
